#include <string>
using namespace std;
/*
* Постановка задачи: написать функцию, которая принимает на вход строку, содержащую путь в файловой системе;
* функция возвращает путь к этому же самому объекту в файловой системе, сокращенный до минимальной длины.
* Какие правила можно использовать для сокращения:
* - Файловая система представляет собой иерархию каталогов (папок);
* - Имя каталога является непустой строкой, состоящей из латинских букв и знаков препинания. Буквы различного регистра считаются разными;
* - Корневой каталог обозначается как `/`;
* - От корневого каталога до любого другого каталога существует уникальный путь. В записи пути каталоги разделяются знаком `/`. Так, если каталог `bar` находится в каталоге `foo`, а каталог `foo` — в корневом каталоге, то полный путь до каталога `bar` выглядит следующим образом: `/foo/bar`;
* - Запись `.` обозначает текущий каталог;
* - Запись `..` обозначает родительский каталог, а для корневого каталога — текущий каталог.
* - Переход на уровень выше `..` можно удалить, если он не в начале пути
* - Переход в текущий каталог `.` можно удалить, если весь путь не состоит из этого единственного символа (то есть это путь к текущей директории)
* - Финальный `/` можно удалить, если весь путь не состоит из этого единственного символа (то есть это путь к корневой директории)
* - Переход из корневой директории на уровень вверх оставляет нас в корневой директории (т.е. `/some_dir/../../../other_dir` == `/other_dir`)
* - Два `/` идущих подряд всегда можно заменить на один
*/

std::string normalize(std::string_view path)
{
    size_t k = 0;
    string ans = "";
    for (size_t i = 0; i < path.length(); i++) {
        ans += path[i];
    }
    if(ans == ".")
    {
        return ".";
    }
    if(ans.length() > 2) {
        bool f = 0;
        if(ans[k] >= 'a' && ans[k] <= 'z')
        {
            f = 1;
        }
        while (k < ans.length() - 3) {
            if (ans[k] == '/'  && ans[k + 1] == '.' && ans[k + 2] == '.' && k != 0 && f == 1) {
                ans.erase(k + 1, 2);
            }
            k++;
        }
    }
    //cout << ans << "       ";
    size_t r = 0;
    int p = 0;
    while(r < ans.length() - 2)
    {
        if(ans[r] >= 'a' && ans[r] <= 'z')
        {
            p++;
        }
        //cout << p;
        if(ans[r] == '.' && ans[r+1] == '.' && p > 0)
        {
            //cout << "hi";
            ans.erase(r , 2);
        }
        r++;
    }
    //cout << ans << "       ";
    while(ans.find("//") != std::string::npos)
    {
        ans.erase(ans.find("//"),1);
    }
    while(ans.find("/./") != std::string::npos)
    {
        if(ans.length() == 1)
        {
            break;
        }
        ans.erase(ans.find("/./"),2);
    }
    while(ans.find("/../") == 0)
    {
        ans.erase(ans.find("/../") + 1,3);
    }


    if(ans.find("/.") == ans.length() - 2)
    {
        ans.erase(ans.find("/.") +1,1);
    }
    /*if(ans.find("..") == 0)
    {
        if(ans.length() != 3 && ans.length() != 2) {
            ans.erase(ans.find(".."), 2);
        }
    }*/

    if(ans[ans.length()-2] == '.' && ans[ans.length()-1] == '.' && ans.length() != 2)
    {
            ans.erase(ans.find(".."), 2);
    }

    size_t u = 0;
    string word1;
    while(u < ans.length())
    {
        if(ans[u] <= 'z' && ans[u] >= 'a')
        {
            word1 = "";
            while(ans[u] != '/' && ans[u] != '.' && u < ans.length()) {
                word1 += ans[u];
                u++;
            }
            u++;
            while(ans.find(word1 + "/" + word1) != std::string::npos)
            {
                ans.erase(ans.find(word1 + "/" + word1), word1.length()+1);
            }
        }else
        {
            u++;
        }

    }


    if(ans[ans.length() - 1] == '/' && ans.length() != 1)
    {
        ans.erase(ans.length()-1, 1);
    }

    return ans;
}
